@everywhere module f
    ##===================================================================================
    ## hyperbolic tangent
    ##===================================================================================
    export tanh, d_tanh

    ##-----------------------------------------------------------------------------------
    tanh(x, eta) = @. Base.tanh(x-eta)

    ##-----------------------------------------------------------------------------------
    d_tanh(x, eta = 0) = @. 1-(tanh(x, eta)^2)


    ##===================================================================================
    ## variance (overload)
    ##===================================================================================
    export var

    ##-----------------------------------------------------------------------------------
    function var{T<:Real}(v::Array{T, 1}, m::T)
        l = length(v)
        return soq(l, v.-m)/l
    end

    ##-----------------------------------------------------------------------------------
    var{T<:Real, N<:Int}(v::Array{T, 1}, m::T, s::N) = soq(s, v.-m)/s


    ##===================================================================================
    ## BLAS wrapper
    ##===================================================================================
    export bdot, bdotc, bnrm2

    ##-----------------------------------------------------------------------------------
    bdot{T<:Real, N<:Int}(l::N, v::Array{T, 1}, u::Array{T, 1}) = BLAS.dot(l, v, 1, u, 1)      # l = length of the vectors

    ##-----------------------------------------------------------------------------------
    bdot{T<:Real}(v::Array{T, 1}, u::Array{T, 1}) = BLAS.dot(length(v), v, 1, u, 1)

    ##-----------------------------------------------------------------------------------
    bdot{T<:Complex, N<:Int}(l::N, v::Array{T, 1}, u::Array{T, 1}) = BLAS.dotu(l, v, 1, u, 1)  # l = length of the vectors

    ##-----------------------------------------------------------------------------------
    bdot{T<:Complex}(v::Array{T, 1}, u::Array{T, 1}) = BLAS.dotu(length(v), v, 1, u, 1)

    ##-----------------------------------------------------------------------------------
    bdotc{T<:Complex, N<:Int}(l::N, v::Array{T, 1}, u::Array{T, 1}) = BLAS.dotc(l, v, 1, u, 1)  # l = length of the vectors

    ##-----------------------------------------------------------------------------------
    bdotc{T<:Complex}(v::Array{T, 1}, u::Array{T, 1}) = BLAS.dotc(length(v), v, 1, u, 1)

    ##-----------------------------------------------------------------------------------
    bnrm2{T<:Real, N<:Int}(l::N, v::Array{T, 1}) = BLAS.nrm2(l, v, 1)                           # l = length of the vector

    ##-----------------------------------------------------------------------------------
    bnrm2{T<:Real}(v::Array{T, 1}) = BLAS.nrm2(length(v), v, 1)


    ##===================================================================================
    ##  soq (sum of squares)
    ##===================================================================================
    export soq

    ##-----------------------------------------------------------------------------------
    soq{T<:Number, N<:Int}(l::N, v::Array{T, 1}) = bdot(l, v, v)

    ##-----------------------------------------------------------------------------------
    soq{T<:Number}(v::Array{T, 1}) = bdot(v, v)


    ##===================================================================================
    ##  collatz conjecture
    ##===================================================================================
    export collatz

    ##-----------------------------------------------------------------------------------
    function collatz{T<:Int}(x::T)
        c = 0
        while x != 4
            x = x%2 == 0 ? x >> 1 : 3*x+1
            c += 1
        end
        return c
    end


    ##===================================================================================
    ## veconomy core function
    ##===================================================================================
    function veconomy_core{T<:Real, N<:Real}(v::Array{T, 1}, cc::N = 0.4)
        lumV = norm(v) / MAX_LUM
        o = prison(rotation_matrix(rand_orthonormal_vec(v), 90)*(v-127.5), -127.5, 127.5)
        while abs(lumv-(norm(o)/MAX_LUM)) < cc; o = map((x) -> x*(lumV>0.5?.5:1.5), o) end
        return map((x) -> prison(round(x), 0, 255), o)
    end


    ##===================================================================================
    ##  dirac delta/impulse
    ##===================================================================================
    export dcd

    ##-----------------------------------------------------------------------------------
    dcd{T<:Number}(x::T) = x == 0 ? inf : 0


    ##===================================================================================
    ## kronecker delta
    ##===================================================================================
    export ked

    ##-----------------------------------------------------------------------------------
    ked(x, y) = ifelse(x == y, 1, 0)


    ##===================================================================================
    ## sigmoid
    ##===================================================================================
    export sigmoid, d_sigmoid

    ##-----------------------------------------------------------------------------------
    sigmoid(x, eta = 0) = 1 / (1 + exp(-(x-eta)))

    ##-----------------------------------------------------------------------------------
    d_sigmoid(x, eta = 0) =  sigmoid(x, eta) * (1-sigmoid(x, eta))


    ##===================================================================================
    ## norm derivate
    ##===================================================================================
    export norn_d

    ##-----------------------------------------------------------------------------------
    nrom_d{T<:Real}(v::Array{T, 1}, p::Int = 2) = (abs(v) ./ ifelse(iszero(v), 1, norm(v, p))).^(p-1) .* sign(v)


    ##===================================================================================
    ## radial basis functions
    ##===================================================================================
    export rbf_gaussian, rbf_gaussian_d_lambda, rbf_gaussian_d_delta, rbf_triang, rbf_cos_decay,
        rbf_multi_quad, rbf_inv_multi_quad, rbf_inv_quad, rbf_poly_harm, rbf_thin_plate_spline

    ##-----------------------------------------------------------------------------------
    rbf_gaussian(delta, lambda = 1) = exp(-(delta/(2*lambda))^2)

    ##-----------------------------------------------------------------------------------
    function rbf_gaussian_d_lambda(delta, lambda = 1)
        delta .^= 2; lam = lambda^2; return (delta./ (lam.*lambda)) .* exp(-delta./lam)
    end

    ##-----------------------------------------------------------------------------------
    function rbf_gaussian_d_delta(delta, lambda = 1)
        lambda ^= 2; return (delta./lambda) .* exp(-(delta.^2)./(2*lambda))
    end

    ##-----------------------------------------------------------------------------------
    rbf_triang(delta, lambda = 1) = delta > lambda ? 0 : (1 - (delta/lambda))

    ##-----------------------------------------------------------------------------------
    rbf_cos_decay(delta, lambda = 1) = delta > lambda ? 0 : ((cos((pi*delta)/(2*lambda)))+1)/2

    ##-----------------------------------------------------------------------------------
    rbf_multi_quad(delta, lambda = 1) = sqrt(1+(lambda*delta)^2)

    ##-----------------------------------------------------------------------------------
    rbf_inv_multi_quad(delta, lambda = 1) = 1 / sqrt(1+(lambda*delta)^2)

    ##-----------------------------------------------------------------------------------
    rbf_inv_quad(delta, lambda = 1) = 1 / (1+(lambda*delta)^2)

    ##-----------------------------------------------------------------------------------
    rbf_poly_harm(delta, Exponent = 2) = delta^Exponent

    ##-----------------------------------------------------------------------------------
    rbf_thin_plate_spline(delta, Exponent = 2) = delta^Exponent * log(delta)


    ##===================================================================================
    ## ramp
    ##===================================================================================
    export ramp, d_ramp

    ##-----------------------------------------------------------------------------------
    ramp(x, eta) = max(0, x-eta)

    ##-----------------------------------------------------------------------------------
    d_ramp(x, eta) = ifelse(x-eta > 0, 1, 0)


    ##===================================================================================
    ## semi linear
    ##===================================================================================
    export semi_lin, d_semi_lin

    ##-----------------------------------------------------------------------------------
    semi_lin(x, eta, sigma = 0.5) = prison(x, (x) -> x-eta+sigma, eta-sigma, eta+sigma)

    ##-----------------------------------------------------------------------------------
    d_semi_lin(x, eta, sigma = 0.5) = ifelse(x > eta+sigma || x < eta-sigma, 0.0, 1.0)


    ##===================================================================================
    ## semi linear
    ##===================================================================================
    export sine_saturation, d_sine_saturation

    ##-----------------------------------------------------------------------------------
    sine_saturation(x, eta, sigma = pi/2) = prison(x, (x) -> (sin(x-eta)+1)/2, eta-sigma, eta+sigma)

    ##-----------------------------------------------------------------------------------
    d_sine_saturation(x, eta, sigma = pi/2) = ifelse(x > eta+sigma || x < eta-sigma, 0, cos(x-eta)/2)


    ##===================================================================================
    ## softplus
    ##===================================================================================
    export softplus, d_softplus

    ##-----------------------------------------------------------------------------------
    softplus(x, eta) = log(1+exp(x-eta))

    ##-----------------------------------------------------------------------------------
    d_softplus(x, eta) = 1/(exp(x-eta)+1)


    ##===================================================================================
    ## orthogonal projection (only returning the projection matrices)
    ##===================================================================================
    export op, op_gen

    ##-----------------------------------------------------------------------------------
    op{T<:Real}(b::Array{T, 2}, complex = false) = b*(complex ? b.' : b')               # b is a orthonormal basis

    ##-----------------------------------------------------------------------------------
    op{T<:Real}(b::Array{Array{T, 1}, 1}) = op(vl_to_mat(b), T<:Complex)                # b is a orthonormal basis

    ##-----------------------------------------------------------------------------------
    function op_gen{T<:Real}(b::Array{T, 2}, complex = false)                           # b mustn't be a orthonormal basis
        bt = ifelse(complex, bt.', bt')
        return b\(bt*b)*bt
    end

    ##-----------------------------------------------------------------------------------
    op_gen{T<:Number}(b::Array{Array{T, 1}, 1}) = op_gen(vl_to_mat(b), T<:Complex)


    ##===================================================================================
    ## mutual incoherence
    ##===================================================================================
    export mut_incoherent

    ##-----------------------------------------------------------------------------------
    function mut_incoherent{T<:Number}(m::Array{T, 2}, rows = true, p::Int = 2)         # the lower the better the mutual incoherence property
        inf = 0; m = rows ? m : m'
        for x = 2:size(m, 1), y = 1:(x-1)
            inf = max(norm(bdot(m[x, :], m[y, :]), p), inf)
        end
        return inf
    end

    ##-----------------------------------------------------------------------------------
    function mut_incoherent{T<:Number}(vl::Array{Array{T, 1}}, p::Int = 2)
        inf = 0
        for x = 2:lenght(vl), y = 1:(x-1)
            inf = max(norm(bdot(m[x], m[y]), p), inf)
        end
        return inf
    end


    ##===================================================================================
    ## step
    ##===================================================================================
    export step, d_step

    ##-----------------------------------------------------------------------------------
    step(x, eta = 0.5) = ifelse(x >= eta, 1, 0)

    ##-----------------------------------------------------------------------------------
    d_step{T<:Any}(x::T, eta) = ifelse(x == eta, typemax(T), 0)


    ##===================================================================================
    ## trigonometric
    ##===================================================================================
    export sin2, cos2, versin, aversin, vercos, avercos, coversin, acoversin, covercos, acovercos,
        havsin, ahavsin, havcos, ahavcos, hacoversin, hacovercos

    ##-----------------------------------------------------------------------------------
    sin2(alpha) = return sin(alpha)^2

    ##-----------------------------------------------------------------------------------
    cos2(alpha) = cos(alpha)^2

    ##-----------------------------------------------------------------------------------
    versin(alpha) = 1-cos(alpha)

    ##-----------------------------------------------------------------------------------
    aversin(alpha) = acos(1-alpha)

    ##-----------------------------------------------------------------------------------
    vercos(alpha) = 1+cos(alpha)

    ##-----------------------------------------------------------------------------------
    avercos(alpha) = acos(1+alpha)

    ##-----------------------------------------------------------------------------------
    coversin(alpha) = 1-sin(alpha)

    ##-----------------------------------------------------------------------------------
    acoversin(alpha) = asin(1-alpha)

    ##-----------------------------------------------------------------------------------
    covercos(alpha) = 1+sin(alpha)

    ##-----------------------------------------------------------------------------------
    acovercos(alpha) = asin(1+alpha)

    ##-----------------------------------------------------------------------------------
    havsin(alpha) = versin(alpha)/2

    ##-----------------------------------------------------------------------------------
    ahavsin(alpha) = 2*asin(sqrt(alpha))

    ##-----------------------------------------------------------------------------------
    havcos(alpha) = vercos(alpha)/2

    ##-----------------------------------------------------------------------------------
    ahavcos(alpha) = 2*acos(sqrt(alpha))

    ##-----------------------------------------------------------------------------------
    hacoversin(alpha) = coversin(alpha)/2

    ##-----------------------------------------------------------------------------------
    hacovercos(alpha) = covercos(alpha)/2


    ##===================================================================================
    ## angle
    ##===================================================================================
    export angle, acos_central_angle, asin_central_angle, atan_central_angle, central_angle,
        haversine_central_angle, vincenty_central_angle

    ##-----------------------------------------------------------------------------------
    angle{T<:Real}(u::Array{T, 1}, v::Array{T, 1}, bias = 0) = acosd((abs(bdot(v, u))/(norm(v) * norm(u))) + bias)

    ##-----------------------------------------------------------------------------------
    acos_central_angle{T<:Number}(u::Array{T, 1}, v::Array{T, 1}) = acos(bdot(u,v))             # returns radians / u&v = normal vectors on the circle

    ##-----------------------------------------------------------------------------------
    asin_central_angle{T<:Number}(u::Array{T, 1}, v::Array{T, 1}) = asin(norm(cross(u, v)))     # returns radians / u&v = normal vectors on the circle

    ##-----------------------------------------------------------------------------------
    atan_central_angle{T<:Number}(u::Array{T, 1}, v::Array{T, 1}) = atan(norm(cross(u, v))/bdot(u, v))  # returns radians / u&v = normal vectors on the circle

    ##-----------------------------------------------------------------------------------
    central_angle(pla, plo, sla, slo) = acos((sin(pla)*sin(sla))+(cos(pla)*cos(sla)*cos(abs(plo-slo)))) # returns radians / pla/sla = primary/secondary latitude / plo/slo = primary/secondary longitude

    ##-----------------------------------------------------------------------------------
    haversine_central_angle(pla, plo, sla, slo) = 2*asin(sqrt(havsin(abs(pla-sla))+cos(pla)*cos(sla)*havsin(abs(plo-slo)))) # returns radians / pla/sla = primary/secondary latitude / plo/slo = primary/secondary longitude

    ##-----------------------------------------------------------------------------------
    function vincenty_central_angle(pla, plo, sla, slo)
        longitude_delta = abs(plo-slo)                                                                                      # returns radians / pla/sla = primary/secondary latitude / plo/slo = primary/secondary longitude
        return atan2(sqrt((cos(sla)*sin(longitude_delta))^2+((cos(pla)*sin(sla))-(sin(pla)*cos(sla)*cos(longitude_delta)))^2), (sin(pla)*sin(sla)+cos(pla)*cos(sla)*cos(longitude_delta)))
    end
end

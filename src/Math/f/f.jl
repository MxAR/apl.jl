@everywhere module f
	##===================================================================================
	##  using directives
	##===================================================================================
	using StatsBase
	using cnv
	using op


	##===================================================================================
	##  import directives
	##===================================================================================
	import Base.map, Base.std


	##===================================================================================
	##  types
	##===================================================================================
	type tncbd{T<:AbstractFloat, N<:Integer}	# n dimensional cuboid
		alpha::Array{T, 1}						# infimum (point)
		delta::Array{T, 1}						# diference between supremum and infimum	(s-i)
		n::N									# n
	end

	##===================================================================================
	## std (standart deviation (overload))
	##		m = median
	##===================================================================================
	export std

	##-----------------------------------------------------------------------------------
	function std{T<:AbstractFloat, N<:Integer}(v::Array{T, 1}, l::N, n::N = 1)
		s = n * l
		m = T(0)

		@assert(s <= size(v, 1), "out of bounds error")
		@inbounds for i = 1:n:(n*l)
			m = m + v[i]
		end

		return sqrt(BLAS.dot(l, v, n, v, n)-(m/l)^2)
	end

	##-----------------------------------------------------------------------------------
	std{T<:AbstractFloat, N<:Integer}(v::Array{T, 1}, m::T, l::N, n::N = 1) = sqrt(BLAS.dot(l, v, n, v, n)-m^2)


	

	##===================================================================================
	##  chi distribution
	##===================================================================================
	export chi

	##-----------------------------------------------------------------------------------
	chi(k::Integer) = norm(randn(k))


	##===================================================================================
	##  dice sampling
	##===================================================================================
	export w6, nw6

	##-----------------------------------------------------------------------------------
	w6() = Int(ceil(rand()*6))

	##-----------------------------------------------------------------------------------
	nw6(n::Integer) = sum([w6() for i = 1:n])


    ##===================================================================================
    ##  boolean operators (aggregation)
    ##===================================================================================
    export AND, OR

    ##-----------------------------------------------------------------------------------
    function AND(v::BitArray{1})
        @inbounds for i = 1:size(v, 1)
            if v[i] == false
                return false
            end
        end

        return true
    end

    ##-----------------------------------------------------------------------------------
    function OR(v::BitArray{1})
        @inbounds for i = 1:size(v, 1)
            if v[i] == true
                return true
            end
        end

        return false
    end


    ##===================================================================================
    ##  / (overload)
    ##===================================================================================
	import Base./
	export /

    ##-----------------------------------------------------------------------------------
    function /{T<:AbstractFloat}(x::T, v::Array{T, 1})
        @inbounds for i = 1:size(v, 1)
            v[i] = x/v[i]
        end

        return v
    end


    ##===================================================================================
    ## variance (overload)
    ##===================================================================================
    export var

    ##-----------------------------------------------------------------------------------
    function var{T<:AbstractFloat}(v::Array{T, 1}, m::T)                                # faster implementation
        l = size(v, 1)
        return (soq(l, v)/l) - (m^2)
    end

    ##-----------------------------------------------------------------------------------
    function var{T<:AbstractFloat}(v::Array{T, 1})                                      # faster implementation
        l = size(v, 1)
        return (soq(l, v)/l) - (gamean(l, v)^2)
    end

    ##-----------------------------------------------------------------------------------
    var{T<:AbstractFloat, N<:Integer}(v::Array{T, 1}, m::T, l::N) = (soq(l, v)/l) - (m^2)

    ##-----------------------------------------------------------------------------------
    var{T<:AbstractFloat, N<:Integer}(v::Array{T, 1}, l::N) = (soq(l, v)/l) - (gamean(l, v)^2)





    ##===================================================================================
    ##  collatz conjecture
    ##===================================================================================
    export collatz

    ##-----------------------------------------------------------------------------------
    function collatz{T<:Integer}(x::T)
		@assert(x > 0, "out of bounds error")
		c = UInt(0)

        while x != 4
            if x & 1 == 1
                x = 3*x +1
            end

            x = x >> 1
            c = c + 1
        end

        return c
    end


    ##===================================================================================
    ## veconomy core function
    ##===================================================================================
    function veconomy_core{T<:AbstractFloat}(v::Array{T, 1}, cc::T = 0.4)
        lumV = norm(v) / MAX_LUM
        o = prison(rotmat_3d(rand_orthonormal_vec(v), 90)*(v-127.5), -127.5, 127.5)
        while abs(lumv-(norm(o)/MAX_LUM)) < cc; o = map((x) -> x*(lumV>0.5?.5:1.5), o) end
        return map((x) -> prison(round(x), 0, 255), o)
    end


    ##===================================================================================
    ##  dirac delta/impulse
    ##===================================================================================
    export dcd

    ##-----------------------------------------------------------------------------------
    function dcd{T<:AbstractFloat}(x::T)
        set_zero_subnormals(true)
        return x == 0 ? Inf : 0
    end

    ##===================================================================================
    ## kronecker delta
    ##===================================================================================
    export ked

    ##-----------------------------------------------------------------------------------
    ked{T<:Number}(x::T, y::T) = x == y ? 1 : 0


    ##===================================================================================
    ##	kronecker product
    ##===================================================================================
    export kep

    ##-----------------------------------------------------------------------------------
    function kep{T<:AbstractFloat}(m::Array{T, 2}, n::Array{T, 2})
		sm = size(m); sn = size(n)
		r = zeros(T, sm[1]^2, sn[1]^2)
		px = py = T(0)

		@inbounds for i = 1:sm[1], j = 1:sm[2]
			px = (i-1)*sm[1]
			py = (j-1)*sm[2]

			for k = 1:sn[1], l = 1:sn[2]
				r[(px+k), (py+l)] = m[i,j]*n[k,l]
			end
		end

		return r
    end


	##===================================================================================
    ## auto regressive model
    ##===================================================================================
	export ar

	##-----------------------------------------------------------------------------------
	function ar{T<:AbstractFloat, N<:Integer}(q::N, v::Array{T, 1})
		l = size(v, 1) - q
		m = zeros(T, l, q+1)
		y = zeros(T, l)

		@inbounds for i = 1:l
			m[i, 1] = 1.
			m[i, 2:end] = v[i:(q+i-1)]
			y[i] = v[q+i]
		end

		return map((x) -> isnan(x) ? 0. : x, (m'*m)\(m'*y))
	end


	##===================================================================================
    ## [augumented] dickey fuller test for stationarity
    ##===================================================================================
	export difut, adifut

	##-----------------------------------------------------------------------------------
	difut{T<:AbstractFloat}(v::Array{T, 1}, p::T = .01) = ar(1, v)[2] <= p

	##-----------------------------------------------------------------------------------
	difut{T<:AbstractFloat}(v::Array{T, 1}, p::T, d::T) = ar(1, v-[d*x for x = 1:size(v, 1)])[2] <= p

	##-----------------------------------------------------------------------------------
	difut{T<:AbstractFloat}(v::Array{T, 1}, p::T, d::T, t::T) = ar(1, v-[(d*x)+(t*sum(x)) for x = 1:size(v, 1)])[2] <= p

	##-----------------------------------------------------------------------------------
	function adifut{T<:AbstractFloat, N<:Integer}(v::Array{T, 1}, q::N, p::T = .01)
		@assert(l > p, "sample size to small")
		d = (circshift(v, -1) - v)[1:end-1]
		l = size(v, 1) - q - 1
		m = zeros(T, l, q + 2)
		y = d[(q+1):end]

		@inbounds for i = 1:l
			m[i, 1] = 1.
			m[i, 2] = v[q+i-1]
			m[i, 3:end] = d[(q+i-1):-1:i]
		end

		return map((x) -> isnan(x) ? 0. : x, (m'*m)\(m'*y))[2] <= p
	end

	##-----------------------------------------------------------------------------------
	adifut{T<:AbstractFloat, N<:Integer}(v::Array{T, 1}, q::N, p::T, d::N) = adifut((v-[d*x for x = 1:size(v, 1)]), q, p)

	##-----------------------------------------------------------------------------------
	adifut{T<:AbstractFloat, N<:Integer}(v::Array{T, 1}, q::N, p::T, d::T, t::T) = adifut((v-[(d*x)+(t*sum(x)) for x = 1:size(v, 1)]), q, p)


	##===================================================================================
    ## angle granger test for cointegration
    ##===================================================================================
	export angrat, aangrat

	##-----------------------------------------------------------------------------------
	angrat{T<:AbstractFloat}(x::Array{T, 1}, y::Array{T, 1}, p::T = .01) = difut(y - (((soq(x))\dot(x, y))*x), p)

	##-----------------------------------------------------------------------------------
	angrat{T<:AbstractFloat}(x::Array{T, 1}, y::Array{T, 1}, p::T, d::T) = difut(y - (((soq(x))\dot(x, y))*x), p, d)

	##-----------------------------------------------------------------------------------
	aangrat{T<:AbstractFloat}(x::Array{T, 1}, y::Array{T, 1}, p::T, d::T, t::T) = difut(y - (((soq(x))\dot(x, y))*x), p, d, t)

	##-----------------------------------------------------------------------------------
	aangrat{T<:AbstractFloat, N<:Integer}(x::Array{T, 1}, y::Array{T, 1}, q::N, p::T = .01) = difut(y - (((soq(x))\dot(x, y))*x), q, p)

	##-----------------------------------------------------------------------------------
	aangrat{T<:AbstractFloat, N<:Integer}(x::Array{T, 1}, y::Array{T, 1}, q::N, p::T, d::T) = difut(y - (((soq(x))\dot(x, y))*x), q, p, d)

	##-----------------------------------------------------------------------------------
	aangrat{T<:AbstractFloat, N<:Integer}(x::Array{T, 1}, y::Array{T, 1}, q::N, p::T, d::T, t::T) = difut(y - (((soq(x))\dot(x, y))*x), q, p, d, t)





	##===================================================================================
	##	kingsman equation
	##===================================================================================
	export king

	##-----------------------------------------------------------------------------------
	king{T<:AbstractFloat, N<:Integer}(p::T, ca::T, cs::T, c::N) = ((p^(sqrt(2*(c+1))))/(1-p))x*(0.5)*((ca^2)+(cs^2))


    ##===================================================================================
    ## sigmoid
    ##===================================================================================
    export sigmoid, sigmoidd

    ##-----------------------------------------------------------------------------------
    sigmoid(x, eta = 0) = @. 1/(1+exp(-(x-eta)))

    ##-----------------------------------------------------------------------------------
    sigmoidd(x, eta = 0) =  @. sigmoid(x, eta) * (1-sigmoid(x, eta))


    ##===================================================================================
    ## norm derivate
    ##===================================================================================
    export normd

    ##-----------------------------------------------------------------------------------
    nromd(v::Array{Float64, 1}, p::Int64 = 2) = @. sign(v)*(abs(v)/ifelse(iszero(v), 1, norm(v, p)))^(p-1)


    ##===================================================================================
    ## radial basis functions
    ##===================================================================================
    export rbf_gaussian, rbf_gaussian_d_lambda, rbf_gaussian_d_delta, rbf_triang, rbf_cos_decay,
        rbf_psq, rbf_inv_psq, rbf_inv_sq, rbf_exp, rbf_thin_plate_spline

    ##-----------------------------------------------------------------------------------
    rbf_gaussian(delta, lambda::Float64 = 1) = @. exp(-(delta/(2*lambda))^2)

    ##-----------------------------------------------------------------------------------
    function rbf_gaussian_d_lambda(delta, lambda::Float64 = 1)
        @. delta ^= 2
        lam = lambda^2
        return @. (delta/(lam*lambda))*exp(-delta/lam)
    end

    ##-----------------------------------------------------------------------------------
    function rbf_gaussian_d_delta(delta, lambda::Float64 = 1)
        @. lambda ^= 2
        return @. (delta./lambda) .* exp(-(delta.^2)./(2*lambda))
    end

    ##-----------------------------------------------------------------------------------
    rbf_triang(delta::Float64, lambda::Float64 = 1) = delta > lambda ? 0. : (1 - (delta/lambda))

    ##-----------------------------------------------------------------------------------
    function rbf_triang(delta::Array{Float64, 1}, lambda::Float64 = 1)
        if AND(delta .> lambda)
            return zeros(delta)
        else
            return (1.-(delta./lambda))
        end
    end

    ##-----------------------------------------------------------------------------------
    rbf_cos_decay(delta::Float64, lambda::Float64 = 1) = delta > lambda ? 0. : ((cos((pi*delta)/(2*lambda)))+1)/2

    ##-----------------------------------------------------------------------------------
    function rbf_cos_decay(delta::Array{Float64, 1}, lambda::Float64 = 1)
        if AND(delta .> lambda)
            return zeros(delta)
        else
            return @. ((cos((pi*delta)/(2*lambda))).+1)/2
        end
    end

    ##-----------------------------------------------------------------------------------
    rbf_psq(delta, lambda::Float64 = 1) = @. sqrt(1+(lambda*delta)^2)

    ##-----------------------------------------------------------------------------------
    rbf_inv_psq(delta, lambda::Float64 = 1) = @. 1/sqrt(1+(lambda*delta)^2)

    ##-----------------------------------------------------------------------------------
    rbf_inv_sq(delta, lambda::Float64 = 1) = @. 1/(1+(lambda*delta)^2)

    ##-----------------------------------------------------------------------------------
    rbf_exp(delta, expt::Float64 = 2) = delta.^expt

    ##-----------------------------------------------------------------------------------
    rbf_thin_plate_spline(delta, expt::Float64 = 2) = @. (delta^expt)*log(delta)


    ##===================================================================================
    ## ramp
    ##===================================================================================
    export ramp, rampd

    ##-----------------------------------------------------------------------------------
    ramp(x, eta) = @. max(0, x-eta)

    ##-----------------------------------------------------------------------------------
    rampd{T<:AbstractFloat}(x::T, eta::T) = x-eta > 0 ? T(1) : T(0)

    ##-----------------------------------------------------------------------------------
    rampd{T<:AbstractFloat}(x::Array{T, 1}, eta::T) = AND(x.-eta .> 0) ? ones(T, x) : zeros(T, x)

    ##-----------------------------------------------------------------------------------
    function rampd{T<:AbstractFloat}(x::Array{T, 1}, eta::Array{T, 1})
        r = zeros(T, x)

        @inbounds for i = 1:size(x, 1)
            if x[i]-eta[i] > 0
                r[i] = 1.
            end
        end

        return r
    end

    ##===================================================================================
    ## semi linear
    ##===================================================================================
    export semilin, semilind

    ##-----------------------------------------------------------------------------------
    semilin(x, eta, sigma = 0.5) = prison(x, (x) -> x-eta+sigma, eta-sigma, eta+sigma)

    ##-----------------------------------------------------------------------------------
    semilind(x, eta, sigma = 0.5) = (x > eta+sigma || x < eta-sigma) ? 0. : 1.


    ##===================================================================================
    ## sine saturation
    ##===================================================================================
    export sine_saturation, sine_saturation_d

    ##-----------------------------------------------------------------------------------
    sine_saturation(x, eta, sigma = pi/2) = prison(x, (x) -> (sin(x-eta)+1)/2, eta-sigma, eta+sigma)

    ##-----------------------------------------------------------------------------------
    sine_saturation_d(x, eta, sigma = pi/2) = (x > eta+sigma || x < eta-sigma) ? 0 : cos(x-eta)/2


    ##===================================================================================
    ## softplus
    ##===================================================================================
    export softplus, softplusd

    ##-----------------------------------------------------------------------------------
    softplus(x, eta) = @. log(1+exp(x-eta))

    ##-----------------------------------------------------------------------------------
    softplusd(x, eta) = @. 1/(exp(x-eta)+1)


    ##===================================================================================
    ## mutual incoherence
    ##===================================================================================
    export mut_incoherent

    ##-----------------------------------------------------------------------------------
    function mut_incoherent{T<:Number, N<:Integer}(m::Array{T, 2}, rows = true, p::N = 2)         # the lower the better the mutual incoherence property
        m = rows ? m : m'
		inf = 0

		for x = 2:size(m, 1), y = 1:(x-1)
            inf = max(norm(bdot(m[x, :], m[y, :]), p), inf)
        end

		return inf
    end

    ##-----------------------------------------------------------------------------------
    function mut_incoherent{T<:Number, N<:Integer}(vl::Array{Array{T, 1}}, p::N = 2)
        inf = 0

        @inbounds for x = 2:lenght(vl), y = 1:(x-1)
            inf = max(norm(bdot(m[x], m[y]), p), inf)
        end

		return inf
    end


    ##===================================================================================
    ## step
    ##===================================================================================
    export step, stepd

    ##-----------------------------------------------------------------------------------
    step(x, eta = 0.5) = @. ifelse(x >= eta, 1, 0)

    ##-----------------------------------------------------------------------------------
    stepd{T<:Number}(x::T, eta) = @. ifelse(x == eta, typemax(T), 0)





    ##===================================================================================
    ## normalize (statiscally)
    ##===================================================================================
    export normalize_s, normalize_sp, normalize_sps

    ##-----------------------------------------------------------------------------------
    function normalize_s{T<:Number}(m::Array{T, 2}, column::Bool = true)                # sets variance to 1 and mean to 0
		r = column ? m : m'
		d = size(r, 1)

        @inbounds for w = 1:size(r, 2)
            r[1:d, w] = (r[1:d, w] - median(r[1:d, w])) / std(r[1:d, w])
        end

        return r
    end

	##-----------------------------------------------------------------------------------
    function normalize_sp{T<:Number}(m::Array{T, 2}, column::Bool = true)
		r = column ? m : m'
		d = size(m, 1)

        @sync @parallel for w = 1:size(r, 2)
            r[1:d, w] = (r[1:d, w] - median(r[1:d, w])) / std(r[1:d, w])
        end

        return r
    end

    ##-----------------------------------------------------------------------------------
    function normalize_sps{T<:Number}(m::Array{T, 2}, column::Bool = true)
		r = convert(SharedArray, column ? m : m')
		d = size(r, 1)

        @inbounds @sync @parallel for w = 1:size(r, 2)
            r[1:d, w] = (r[1:d, w] - median(r[1:d, w])) / std(r[1:d, w])
        end

        return convert(Array, r)
    end


    ##===================================================================================
    ## rotation matrix
    ##===================================================================================
    export rotmat_3d

	##-----------------------------------------------------------------------------------
	rotmat_2d{T<:AbstractFloat}(angle::T = T(90)) = [cos(angle) -sin(angle); sin(angle) cos(angle)]

    ##-----------------------------------------------------------------------------------
    function rotmat_3d{T<:AbstractFloat}(axis::Array{T, 1}, angle::T = T(90))
        axis = axis'
        m = [ 0 -axis[3] axis[2]; axis[3] 0 -axis[1]; -axis[2] axis[1] 0 ]
        return eye(T, 3) + m * sind(alpha) + (1 - cosd(alpha)) * m^2
    end

    ##===================================================================================
    ## covariance
    ##===================================================================================
    export cov

    ##-----------------------------------------------------------------------------------
    function cov{T<:AbstractFloat, N<:Integer}(l::N, x::Array{T, 1}, n1::N, y::Array{T, 1}, n2::N)
        m1 = m2 = T(0)

		s = n1*l
		@assert(s <= size(x, 1), "out of bounds error")
        @inbounds for i = 1:n1:(n1*l)
            m1 = m1 + x[i]
        end

		s = n2*l
		@assert(s <= size(y, 1), "out of bounds error")
        @inbounds for i = 1:n2:(n2*l)
            m2 = m2 + y[i]
        end

        m1 = m1/l
        m2 = m2/l

        return (BLAS.dot(l, x, n1, y, n2)/l)-(m1*m2)
    end

    ##-----------------------------------------------------------------------------------
    cov{T<:AbstractFloat, N<:Integer}(l::N, x::Array{T, 1}, n::N, d::N = N(1)) = cov(l, x, n, x[d+1:end], n)     # d = delay


    ##===================================================================================
    ## covariance matrices from observations
    ##===================================================================================
    export covp, covs

    ##-----------------------------------------------------------------------------------
    function covp{T<:AbstractFloat}(m::Array{T, 2}, column::Bool = true)                # cov population
        s = size(x, (column ? 1 : 2))
        v = BLAS.gemv((column ? 'T' : 'N'), m, ones(T, s))
		return column ? BLAS.gemm('T', 'N', 1/s, m, m) - (bnrm(v)/v)^2 : BLAS.gemm('N', 'T', 1/s, m, m) - (bnrm(v)/v)^2
    end

    ##-----------------------------------------------------------------------------------
    function covs{T<:AbstractFloat}(m::Array{T, 2}, column::Bool = true)                # cov sample
        s = size(m, (column ? 1 : 2))
        v = BLAS.gemv((column ? 'T' : 'N'), m, ones(T, s))
        return column ? BLAS.gemm('T', 'N', 1/(s-1), m, m) - (bdot(v, v) / (v*(v-1))) : BLAS.gemm('N', 'T', 1/(s-1), m, m) - (bdot(v, v) / (v*(v-1)))
    end


    ##===================================================================================
    ## cross covariance
    ##===================================================================================
    export covc

    ##-----------------------------------------------------------------------------------
    function covc{T<:AbstractFloat}(x::Array{T, 1}, y::Array{T, 1})
        xs = size(x, 1); xm = gamean(x, xs, 1)
		ys = size(y, 1); ym = gamean(y, ys, 1)

        r = zeros(T, xs, ys)
		sc = 1/(xs*ys)

		@inbounds for xi = 1:xs, yi = 1:ys
            r[xi, yi] = cov(x[xi], xm, y[yi], ym, sc)
        end

        return r
    end


    ##===================================================================================
    ## cross covariance sumed (with delay)
    ##===================================================================================
    export covcs

    ##-----------------------------------------------------------------------------------
    covcs{T<:AbstractFloat, N<:Integer}(v::Array{T, 1}, u::Array{T, 1}, t::N = N(1)) = bdot((l-t), (v-gamean(size(v, 1), v, 1)), (circshift(u, t)-gamean(size(u, 1), u, 1)))/(l-t)


    ##===================================================================================
    ## cross correlation (with delay)
    ##===================================================================================
    export ccor

    ##-----------------------------------------------------------------------------------
    ccor{T<:AbstractFloat, N<:Integer}(v::Array{T, 1}, u::Array{T, 1}, t::N = N(1)) = covcs(v, u, t)./(std(v)*std(u))


    ##===================================================================================
    ## supp (support)
    ##===================================================================================
    export supp

    ##-----------------------------------------------------------------------------------
    function supp{T<:AbstractFloat}(v::Array{T, 1}, f::Function = (x::T) -> x)
        set_zero_subnormals(true)
        u = Array{T, 1}

        @inbounds for i = 1:size(v, 1)
			if abs(f(x)) == 0
				push!(u, v[i])
			end
		end

        return u
    end

    ##-----------------------------------------------------------------------------------
    function supp{T<:AbstractFloat}(vl::Array{Array{T, 1}, 1}, f::Function = (x::T) -> x)# supp for vector lists
        ul = Array{Array{T, 1}, 1}
        set_zero_subnormals(true)

        @inbounds for i = 1:size(vl, 1)
			if AND(abs(f(x)) .== 0)
				push!(ul, v[i])
			end
		end

		return ul
    end


	##===================================================================================
	##	shannon index
	##===================================================================================
	export shai

	##-----------------------------------------------------------------------------------
	shai{T<:AbstractFloat, N<:Integer}(v::Array{T, 1}, l::N, n::N) = BLAS.dot(l, v, n, log.(v[1:n:(n*l)]), 1)


	##===================================================================================
	##	Gini–Simpson index
	##===================================================================================
	export gishi

	##-----------------------------------------------------------------------------------
	gishi{T<:AbstractFloat, N<:Integer}(v::Array{T, 1}, l::N, n::N) = 1 - BLAS.dot(l, v, n, v, n)


	##===================================================================================
	##	Renyi Entropy
	##===================================================================================
	export reepy

	##-----------------------------------------------------------------------------------
	function reepy{T<:AbstractFloat, N<:Integer}(v::Array{T, 1}, p::N, l::N, n::N)
		s = n * l
		u = v[i]

		@assert(s <= size(v, 1), "out of bounds error")
		@inbounds for i = 1+n:n:s
			u += v[i]^p
		end

		return log(u)/(1-p)
	end


	##===================================================================================
	##	check status of the nth bit
	##===================================================================================
	export nbit_on, nbit_off

	##-----------------------------------------------------------------------------------
	nbit_on{T<:Integer}(x::T, i::Integer) = (x >> (i-1)) & T(1) == T(1)

	##-----------------------------------------------------------------------------------
	nbit_off{T<:Integer}(x::T, i::Integer) = xor((x >> (i-1)), T(1)) == T(1)


	##===================================================================================
	##	print binary representation
	##===================================================================================
	export bprint

	##-----------------------------------------------------------------------------------
	function bprint{T<:Integer}(x::T, bigendian::Bool = true)
		println(bigendian ? reverse(bits(x)) : bits(x))
	end


	##===================================================================================
	##	sizeof (in bits)
	##===================================================================================
	export sizeofb

	##-----------------------------------------------------------------------------------
	sizeofb(x::DataType) = sizeof(x)*8


	##===================================================================================
	##	invert bit range
	##===================================================================================
	export ibit_range

	##-----------------------------------------------------------------------------------
	ibit_range{T<:Unsigned}(x::T, lb::Integer, ub::Integer) = T(xor(sum([T(1) << x for x = (lb-1):(ub-1)]), x))


	##===================================================================================
	##	exchange bit range
	##===================================================================================
	export ebit_range

	##-----------------------------------------------------------------------------------
	function ebit_range{T<:Unsigned}(x::T, y::T, lb::Integer, ub::Integer)
		c = sum([T(1) << i for i = (lb-1):(ub-1)])
		d = ~c
		return (T(xor((x & d), (y & c))), T(xor((y & d), (x & c))))
	end

	##===================================================================================
	##	flip bit
	##===================================================================================
	export fbit

	##-----------------------------------------------------------------------------------
	fbit{T<:Unsigned}(x::T, i::Integer) = xor(x, T(1 << (i-1)))


	##===================================================================================
	##	set bit
	##===================================================================================
	export sbit

	##-----------------------------------------------------------------------------------
	sbit{T<:Unsigned}(x::T, i::Integer, v::Bool) = (nbit_on(x, i) == v) ? x : xor(x, T(1 << (i-1)))


	##===================================================================================
	##	column wise binary merge
	##===================================================================================
	export cb_merge

	##-----------------------------------------------------------------------------------
	function cb_merge{T<:Unsigned}(v::Array{T, 1})
		s = sizeofb(T)																	# r = A B C D E F G H I J K L M N O
		c = UInt8(1)																	# 	v[1] = A D G J M
		f = T(1)																		# 	v[2] = B E H K N
		r = T(0)																		# 	v[3] = C F I L O

		for i = 1:s, j = 1:size(v, 1)
			if nbit_on(v[j], i)
				r = xor(r, f)
			end

			if c == s
				return r
			end

			f <<= 1
			c += 1
		end
	end


	##===================================================================================
	##	split column wise binary merge again (cb_merge reverse)
	##===================================================================================
	export cb_split

	##-----------------------------------------------------------------------------------
	function cb_split{T<:Unsigned}(x::T, d::Integer)										# d = number of dimensions
		r = Array{T, 1}(zeros(d))
		s = sizeofb(T)
		c = UInt8(1)
		f = T(1)

		for i = 1:s
			for j = 1:d
				if nbit_on(x, c)
					r[j] = xor(r[j], f)
				end

				if c == s
					return r
				end
				c += 1
			end
			f <<= 1
		end
	end


	##===================================================================================
	##	gray codes (forward/backward)
	##===================================================================================
	export grayf, grayb

	##-----------------------------------------------------------------------------------
	grayf{T<:Unsigned}(x::T) = xor(x, (x >> 1))

	##-----------------------------------------------------------------------------------
	function grayb{T<:Unsigned}(x::T)
		y = x; r = x

		while y != T(0)
			y >>= 1
			r = xor(r, y)
		end

		return r
	end


	##===================================================================================
	##	hilbert curve (forward/backward)
	##===================================================================================
	export hilbert_cf, hilbert_cb

	##-----------------------------------------------------------------------------------
	function hilbert_cf{T<:Unsigned}(v::Array{T, 1})									# TODO support for different output types is needed
		b = sizeof(T)*8
		r = deepcopy(v)

		for i = (b-1):-1:1, j = 1:size(r, 1)
			if nbit_on(r[j], i)
				r[1] = ibit_range(r[1], i+1, b-1)
			else
				s = ebit_range(r[1], r[j], i+1, b-1)
				r[1] = s[1]
				r[j] = s[2]
			end
			println(r)
		end

		return grayf(cb_merge(r))
	end

	##-----------------------------------------------------------------------------------
	function hilbert_cb{T<:Unsigned}(v::T, d::Integer)
		r = cb_split(grayb(v), d)
		b = sizeof(T)*8

		println(r)

		for i = 1:b, j = d:-1:1
			if nbit_on(r[j], i)
				r[1] = ibit_range(r[1], i+1, b)
			else
				s = ebit_range(r[1], r[j], i+1, b)
				r[1] = s[1]
				r[j] = s[2]
			end
			println(r)
		end

		return r
	end


	##===================================================================================
	##	Sawtooth wave
	##===================================================================================
	export saww

	##-----------------------------------------------------------------------------------
	saww{T<:AbstractFloat}(x::T, a::T, p::T, q::T) = (-2*a/pi)*atan(cot((x-q)*pi/p))	# a = amplitude, p = period, q = phase


	##===================================================================================
	##	Square wave
	##===================================================================================
	export sqw

	##-----------------------------------------------------------------------------------
	sqw{T<:AbstractFloat}(x::T, a::T, p::T, q::T) = a*sign(sin((x-q)*q))				# a = amplitude, p = period, q = phase


	##===================================================================================
	##	Triangle wave
	##===================================================================================
	export triw

	##-----------------------------------------------------------------------------------
	function triw{T<:AbstractFloat}(x::T, a::T, p::T, q::T)
		s1 = 2/p
		s2 = floor(s1*(x+q)+.5)
		return a*2*s1*((x+q)-s1*s2)*(s2 % 2 == 0 ? 1 : -1)
	end


	##===================================================================================
	## roots of polynomial
	##===================================================================================
	export rop

	##-----------------------------------------------------------------------------------
	function rop{T<:AbstractFloat}(c::Array{T, 1})
		s = size(c, 1)
		reverse!(c)

		@inbounds for i = s:-1:1
			if c[i] != 0
				break
			end
			s -= 1
		end

		m = shift(s-1, false)
		m[1, :] = (-c[2:end])/c[1]
		return map((x) -> 1/x, eigvals(m))
	end


	##===================================================================================
    ## roots of unity
    ##===================================================================================
	export rou

	##-----------------------------------------------------------------------------------
	rou(n::Integer) = [exp((2*pi*i*im)/n) for i = 0:(n-1)]


    ##===================================================================================
    ## samples
    ##===================================================================================
    export samples

    ##-----------------------------------------------------------------------------------
    function samples{T<:Any}(data::Array{T, 1}, size::Integer)
        L = length(data)
        @assert(size < L, "The number of samples musn't be bigger than the data!")
        return shuffle(getindex(data, sort(sample(1:L, size, replace = false))))
    end


    ##===================================================================================
    ## checks
    ##===================================================================================
    export iszero, levi_civita_tensor, index_permutations_count

    ##-----------------------------------------------------------------------------------
    function iszero(v)
		set_zero_subnormals(true)
		sumabs(v) == 0
	end

    ##-----------------------------------------------------------------------------------
    lecit{T<:Number}(v::Array{T, 1}) = 0 == index_permutations_count(v) % 2 ? 1 : -1

    ##-----------------------------------------------------------------------------------
    function index_permutations_count{T<:Any}(v::Array{T, 1})                           # [3,4,5,2,1] -> [1,2,3,4,5]
        s = size(v, 1)                                                            		# 3 inversions needed
        t = linspace(1, s, s)
		c = 0

		while v != t
            @inbounds for i = 1:size(v, 1)
                if v[i] != i
                    s = find(v .== i)
                    if s != i
                        v[s] = v[i]
                        v[i] = i
                        c += 1
                    end
                end
            end
        end

		return c
    end





    ##===================================================================================
    ## rm column/row
    ##===================================================================================
    export rm, rms

    ##-----------------------------------------------------------------------------------
    function rm{T<:Any}(m::Array{T, 2}, i::Integer, column::Bool = true)
		r = column ? m : m'
        return hcat(r[:, 1:(i-1)], r[:, (i+1):end])
    end

    ##-----------------------------------------------------------------------------------
    function rms{T<:Any}(m::Array{T, 2}, i::Array{Any, 1}, column::Bool = true)
		r = column ? m : m'

		@inbounds for x in i
            r = hcat(r[:, 1:(x-1)], r[:, (x+1):end])
            i .-= 1
        end

		return r
    end

    ##-----------------------------------------------------------------------------------
    function rm{T<:Any}(m::Array{T, 2}, i::Array{Any, 1}, column::Bool = true)
		r = column ? m : m'

		@inbounds for x in sort(i)
            r = hcat(r[:, 1:(x-1)], r[:, (x+1):end])
            i .-= 1
        end

        return r
    end

    ##-----------------------------------------------------------------------------------
    function rm{T<:Any, N<:Integer}(m::Array{T, 2}, ub::N, lb::N, column::Bool = true)
		column::Bool = true
        return hcat(r[:, 1:(lb-1)], r[:, (ub+1):end])
    end


    ##===================================================================================
    ## rm
    ##===================================================================================
    export rm, rms

    ##-----------------------------------------------------------------------------------
    function rm{T<:Any, N<:Int}(v::Array{T, 1}, i::Array{N, 1})
        i = sort(i)

        @inbounds for j=1:length(i)
            v = cat(1, v[1:(i[j]-1)], v[(i[j]+1):end])
            i .-= 1
        end

        return v
    end

    ##-----------------------------------------------------------------------------------
    function rms{T<:Any, N<:Int}(v::Array{T, 1}, i::Array{N, 1})
        @inbounds for j=1:length(i)
            v = cat(1, v[1:(i[j]-1)], v[(i[j]+1):end])
            i .-= 1
        end

        return v
    end


    ##===================================================================================
    ## union overload
    ##===================================================================================
    export union

    ##-----------------------------------------------------------------------------------
    function union{T<:Any}(vl::Array{Array{T, 1}, 1})
        v = vl[1]

        @inbounds for i=2:size(vl, 1)
            v = union(v, vl[i])
        end

		return v
    end


    ##===================================================================================
    ## intersect overload
    ##===================================================================================
    export intersect

    ##-----------------------------------------------------------------------------------
    function intersect{T<:Any}(vl::Array{Array{T, 1}, 1})
        v = vl[1]

        @inbounds for i=2:size(vl, 1)
            v = intersect(v, vl[i])
        end

        return v
    end


    ##===================================================================================
    ## prepend
    ##===================================================================================
    export prepend, prepend!

    ##-----------------------------------------------------------------------------------
    prepend{T<:Any}(v::Array{T, 1}, w) = cat(1, [w], v)

    ##-----------------------------------------------------------------------------------
    prepend{T<:Any}(v::Array{T, 1}, w::Array{T, 1}) = cat(1, w, v)

    ##-----------------------------------------------------------------------------------
    prepend!{T<:Any}(v::Array{T, 1}, w) = v = cat(1, [w], v)

    ##-----------------------------------------------------------------------------------
    prepend!{T<:Any}(v::Array{T, 1}, w::Array{T, 1}) = v = cat(1, w, v)





    ##===================================================================================
    ## map (overload)
    ##===================================================================================
    export map

    ##===================================================================================
    function map{T<:Any}(f::Function, vl::Array{Array{T, 1}, 1})
        ul = Array{Array{T, 1}, 1}

        @inbounds @simd for i = 1:length(ul)
            push!(ul, f(ul[i]))
        end

		return ul
    end


	##===================================================================================
    ## min (overload)
    ##===================================================================================
	export min

	##-----------------------------------------------------------------------------------
	min{T<:Number}(x::Tuple{T, T}) = x[1] < x[2] ? x[1] : x[2]


	##===================================================================================
    ## max (overload)
    ##===================================================================================
	export max

	##-----------------------------------------------------------------------------------
	max{T<:Number}(x::Tuple{T, T}) = x[1] > x[2] ? x[1] : x[2]


    ##===================================================================================
    ## apply
    ##===================================================================================
    export apply, apply_parallel, apply_parallel_shared, apply_tri_upper, apply_tri_lower

    ##-----------------------------------------------------------------------------------
    function apply(g::Function, m)
        @inbounds for i in eachindex(m)
            m[i] = g(m[i])
        end

        return m
    end

    ##-----------------------------------------------------------------------------------
    function apply_p(g::Function, m)
        m = convert(SharedArray, m)

		@inbounds @sync @parallel for i in eachindex(m)
            m[i] = g(m[i])
        end

        return convert(Array, m)
    end

    ##-----------------------------------------------------------------------------------
    function apply_ps(g::Function, m)
        @inbounds @sync @parallel for i in eachindex(m)
            m[i] = g(m[i])
        end

        return m
    end

    ##------------------------------------------------------------------------------------
    function apply_tri_upper{T<:Number}(g::Function, m::Array{T, 2})
        @inbounds for j = 2:size(m, 2), i = 1:j-1
            m[i, j] = g(m[i, j])
        end

        return m
    end

    ##------------------------------------------------------------------------------------
    function apply_tri_lower{T<:Number}(g::Function, m::Array{T, 2})
        @inbounds for i = 2:size(m, 2), j = 1:i-1
            m[i, j] = g(m[i, j])
        end

        return m
    end

	##-----------------------------------------------------------------------------------
	function apply_dia{T<:Number}(g::Function, m::Array{T, 2})
		for i = min(size(m))
			m[i, i] = g(m[i, i])
		end

		return m
	end
end

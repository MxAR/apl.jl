@everywhere module op
    ##===================================================================================
    ## aggregations
    ##===================================================================================
    export PI, impure_add, impure_subtract

    ##-----------------------------------------------------------------------------------
    function PI{T<:Real}(N::Array{T, 1})
        p = N[1]
        for i = 2:length(N) p *= N[i] end
        return p
    end

    ##-----------------------------------------------------------------------------------
    function impure_add(V1, V2)
        L = [length(V1), length(V1)]
        V = zeros(maximum(L))
        V[1:L[1]] += V1
        V[1:L[2]] += V2
        return V
    end

    ##-----------------------------------------------------------------------------------
    function impure_subtract{T<:Real}(V1::Array{T, 1}, V2::Array{T, 1})
        L = [length(V1), length(V1)]
        V = zeros(maximum(L))
        V[1:L[1]] += V1
        V[1:L[2]] -= V2
        return V
    end


    ##===================================================================================
    ## prison
    ##===================================================================================
    export prison

    ##-----------------------------------------------------------------------------------
    prison(value, infimum, supremum) = min(max(value, infimum), supremum)

    ##-----------------------------------------------------------------------------------
    prison(x, f::Function, infimum, supremum) = ifelse(x < infimum, 0, ifelse(x > supremum, 1, f(x)))
end
